# 客户端整体运行路径

<img src=".\README.assets\my_TypeWriting流程图.png" alt="my_TypeWriting流程图" style="zoom: 67%;" />

关键点：keyborad中对字符的处理，按键颜色和字符格式的处理以及更新文件的处理

### 整体修改改进处：

1、全部文件存在本地文件夹中，并通过明文保存。可通过增加mysql数据库的方式对文件进行导入，并保存用户数据

2、可以展示登入界面，多人在线登入，并进行打字练习

3、增加多线程对打字数据进行监控，保证能够及时准确的弹出打字练习的错误窗口

### 改进方式：

1、建立网络通讯，完成客户端与服务器的网络通讯方式。

- 学习qt网络通讯 API 方式
- 保存部分信息在文件中，待打字材料信息材料信息。

## 客户端业务流程

1、打开软件，第一个界面为登入界面

> 需要有个注册界面

2、登入界面打开后自动与服务器建立连接

- 发送消息格式Http格式，长连接

3、输入账号、密码

> 服务器：检测通过输入的密码后返回可供使用的打字文档目录（服务器需要存在一个专门存储目录的位置）

4、客户端：如果账号密码正确，打开第一个界面 -> 包含很多可练习文档条目 + 单个条目个人打字记录

5.1、点击练习目录，进入 KeyBoard 界面，

- 子线程接收数据，并将数据写入到当前编程文件中
- KeyBoard 界面开始读取文件中的数据，并显示一行在界面中
- 练习结束后将打字练习结果发送给服务端

> 服务端将数据处理后加入到个人打字信息列表中

5.2、点击单个条目个人记录，

- 子线程想服务端请求个人打字信息，并将请求到的数据写入到某个文件列表中
- 界面主线程读取文件信息，并显示在列表页上

备注：

> 每次需要请求的界面出现时，都向服务器请求数据。

> 不考虑网络不好的情况

### 登入界面

<img src=".\README.assets\image-20230727195409572.png" alt="image-20230727195409572" style="zoom:67%;" />

要求：有背景，有软件登入界面说明，有账号，密码，是否记住密码，登入按钮，注册按钮

功能：

1、检测账号密码输入是否为空

2、调用 socket 连接

3、接收到服务器发过来的消息后，进入 练习子界面

### 注册界面

<img src=".\README.assets\image-20230727200306084.png" alt="image-20230727200306084" style="zoom: 67%;" />

要求：有背景，账号和密码检测，注册按钮

功能：

1、检测注册账号和密码格式是否正确

2、调用socket连接

3、接收到注册成功消息后关闭窗口进入登入界面

### ClientConn 建立连接和管理连接

要求：封装连接，只有一个实例，完成与server连接功能

功能：

1、能够主动与服务器建立连接，能够完成与服务器

2、程序打开自动调用子线程运行

3、从主机读到得信息并放入缓冲区中 （是否需要建立一个消息池用于与不同窗口通行）

4、提供通讯接口，转发消息，并将接收到的消息发送给调用者

细分功能：

有一个初始化函数、写数据槽、读数据槽、关闭槽

**思考问题1**：使用单例模式，表示只有一个实例，那么在整个程序运行过程中都只有这一个实例提供 tcp 连接服务，如果连接失败，一直等待。

**思考问题2**：这个实例需要提供什么可用接口？

提供创建接口，提供写入数据接口，读取数据并将数据写入某个文件中或者内存某个地方。需要提供不同写入方式。

**思考问题3**：有哪些数据需要通过服务器获取？有哪些信息发送给服务器？

发送的信息：注册信息，登入信息、请求的打字文件目录、请求的打字文件数据、请求的单个打字排名数据

获取的信息：注册成功信息、登入成功信息、响应的打字目录文件、响应的打字文件数据，响应的打字排名数据

**思考问题4**：这些数据的协议是什么？

都采用不完整的 http 格式吧

请求行 + 消息头  消息体

<img src="F:\2、项目资料与论文\3-打字程序软著\my_TypeWriting\README.assets\image-20230802215415867.png" alt="image-20230802215415867" style="zoom: 50%;" />

<img src="F:\2、项目资料与论文\3-打字程序软著\my_TypeWriting\README.assets\image-20230802215246637.png" alt="image-20230802215246637" style="zoom: 50%;" />

<img src="F:\2、项目资料与论文\3-打字程序软著\my_TypeWriting\README.assets\image-20230802215350292.png" alt="image-20230802215350292" style="zoom:50%;" />



# 基本服务器框架 - baseserver

这个是基本的服务器框架，已经可以完成接收和发送任务

## 采用模式
+ 模拟 proactor 模式

主线程模拟内核接收发送过来的数据，并将数据从内核空间中搬运到用户缓冲区中，并将待处理的任务加入到待处理队列中，等待子线程从队列获取任务并处理

线程池中的子线程负责从待处理队列中获取待处理的任务，解析任务，并更根据请求信息生成返回数据，并将这个数据写入到缓冲区中

可使用 reactor 模式


## 线程池
+ 线程池采用随机算法

通过主线程中生成很多线程，然后 epoll 检测到 socket 缓冲区中数据时(有连接信息发送过来)，将 socket 中的缓冲区的数据读出，然后调用将它加入到队列中。此时线程池中的**信号量**增加，使得阻塞在 `sem_wait` 的线程解除阻塞状态，内核会从一堆被阻塞的子线程中选取一个子线程，其他子线程仍然阻塞在`sem_wait` 中。这个解除阻塞的子线程加锁，确保同一时刻只有一个子线程在获取队列中的任务。获取任务后，解锁，并将**信号量**减一。

## 使用 epoll 模式的 ET 模式
+ epoll 模式

在内核中创建一个 epoll 实例(红黑树)，将需要检测的 socket 文件描述符加入红黑树中，让内核帮我们检测那个 socket 缓冲区中有数据。

有数据时，此时就会将阻塞在 `epoll_wiat` 的用户进程唤醒，用户进程会得到一个装满数据的 epoll_event 数组，遍历这个数组，依次判断数组中的 epoll_event 事件是什么类型，然后根据不同的类型做不同的处理。

我们在将文件描述符加入到红黑树时，已经设置了事件检测类型，内核会针对我们设定的类型做判断，然后将符合设定事件的文件描述符加入到 epoll_event 数组中。需要注意的是，返回的 epoll_event 中包含该 socket 所有的事件，都可以检测，读事件和写事件必然被返回。

# Http 服务器 - webserver
采用上文中的基本server架构，并完成了HTTP消息的消息的解析和生成响应。目前采用 HTTP/1.0 协议，仅支持 GET 请求，同时仅对部分请求头进行了回应，并生成响应。

### 编译指令（防止忘记）
`g++ -o server ./src/*.cpp -I ./include -pthread`

### 采用 webbranch 压力测试
`./webbranch -c 1000 -t 10 http://IP:port/index.html`
+    -c 表示访问个数 -t 表示访问时间
+ 压力测试软件，文件目录下 make 即可

## 技术栈：
+ 内存映射将响应文件，mmap
+ 采用可变参数函数
+ 使用 ioev 分块写方式
+ 采用正则表达式解析 http 请求头（C++的正则表达式好像在不同平台表现不同）
+ 信号捕获处理
+ 信号量同步，锁互斥访问，保证数据安全
+ 匿名管道

## 加入定时器

1. 何时创建 HttpConn 的定时器以及何时将定时器加入到定时器队列中？

创建新连接后，初始化 HttpConn 前，new 一个定时器，然后将定时器装载到 HttpConn 中，同时将这个定时器加入到定时器队列中。每个定时器创建时会设置定时时间：`3 * TIMESLOT + curtime` ，每隔 5 会检测一次，队列中定时器时间与当前时间的大小，小于当前时间即为超时，需要强制关闭。如果超时前收到数据，则重新设置超时时间。

2. 如何发出一个定时信号，并处理信号？

主线程中开始 EPOLL 检测前，创建一个定时器，设置定时时间。内核会自动进行定时，当定时时间到后，发出 SIGALARM 信号，然后通过信号捕获机制，自定义捕获函数，将信号加入到匿名 socket 中。

3. 怎么检测定时器超时触发了

服务器启动时会创建一对匿名 socket ，fd[0] 设置成读出，fd[1] 设置成写入, 并将 fd[0] 加入到 epoll 中检测。当内核发出定时信号后，被用户信号捕获函数捕获，该函数将信号从 fd[1] 加入到匿名 socket 中。此时 epoll 实例就会检测到 fd[0] 中有缓冲数据，将和其他的 socket 一样返回这个描述符给用户主线程。

4. 检测到匿名 socket 的读事件的后续处理？

当检测到读时间后，就会在主线程中将 socket 中的数据读出来。并通过 recv 返回得到信号的个数，循环读到的信号，判断信号类型，如果是 SIGALARM ，则将 timeout 设置成 true，延后处理，因为 IO 操作优先级更高。

5. 定时器部分

创建一个定时器类 timer 和一个定时器队列 Sort_Timer_List ，其中定时器类主要存储定时器的超时事件。定时器队列则是由定时器组成的有序队列（目前采用链表，后期可修改为红黑树），用于管理定时器。可添加，删除，修改定时器以及超时检测。
